#ifndef LAUNCH_CORE_UDPLAYER_
#define LAUNCH_CORE_UDPLAYER_

#include "../../net/socket/Socket.h"
#include "../../net/packet/Packet.h"
#include "../../net/network_layer/NetworkLayer.h"
#include "../../vector/vector.h"
#include "udp.h"
#include <stdint.h>

namespace udp {
    static const size_t SIZE = 25;

    class UDPLayer : public NetworkLayer {
    public:
        UDP() : src_port(port_num) {
        }

        RetType create_receive_port(uint16_t port_num) {
            this->receive_ports.push_back(port_num);

            return RET_SUCCESS;
        };

        RetType receive(Packet &packet, sockmsg_t &info, NetworkLayer *caller) {
            RESUME();

            UDP_HEADER_T *header = packet.read_ptr<UDP_HEADER_T>();

            if (!header) {
                return RET_ERROR;
            }

            int checksum = 0; // TODO: Figure out how to pull checksum
            if (verify_checksum(info.payload, checksum)) {
                return RET_ERROR;
            }


            for (int i = 0; i < receive_ports.size(); i++) {

            }

            RetType ret = CALL(next->receive(packet, info, this))

            RESET();

            return ret;
        }

        RetType transmit(Packet &packet, sockmsg_t &info, NetworkLayer *caller) {
            RESUME();

            UDP_HEADER_T header = packet.allocate_header<UDP_HEADER_T>();

            if (header) {
                return RET_ERROR;
            }

            header.src = ;
            header.dst = ;
            header.checksum = ;
            header.data_octets = ;
            header.length = ;

            RetType ret = CALL(route->next->transmit(packet, info, this));

            RESET();
            return ret;
        }

    private:
        uint16_t src_port;
        alloc::Vector<uint16_t, SIZE> receive_ports;


    };
}

#endif //LAUNCH_CORE_UDPLAYER_
