#ifndef LAUNCH_CORE_UDPLAYER_
#define LAUNCH_CORE_UDPLAYER_

#include "../../net/socket/Socket.h"
#include "../../net/packet/Packet.h"
#include "../../net/network_layer/NetworkLayer.h"
#include "../../vector/vector.h"
#include "udp.h"
#include <stdint.h>

namespace udp {
    static const size_t SIZE = 25;

    class UDPLayer : public NetworkLayer {
    public:
        UDP() : src_port(port_num) {
        }

        RetType create_receive_port(uint16_t port_num) {
            this->receive_ports.push_back(port_num);

            return RET_SUCCESS;
        };

        RetType receive(Packet &packet, sockmsg_t &info, NetworkLayer *caller) {
            RESUME();

            UDP_HEADER_T *header = packet.read_ptr<UDP_HEADER_T>();

            if (!header) {
                return RET_ERROR;
            }

            RetType ret = CALL(next->receive(packet, info, this))

            RESET();

            return ret;
        }

        RetType transmit(Packet &packet, sockmsg_t &info, NetworkLayer *caller) {
            RESUME();

            UDP_HEADER_T header = packet.allocate_header<UDP_HEADER_T>();

            if (header) {
                return RET_ERROR;
            }

            header.src = 0;
            header.dst = info.port;
            header.checksum = 0;
            header.data_octets = packet.read_ptr<uint32_t>();
            header.length = info.payload_len;

            RetType ret = CALL(route->next->transmit(packet, info, this));

            RESET();
            return ret;
        }

    private:
        uint16_t src_port;
        alloc::Vector<uint16_t, SIZE> receive_ports;


    };
}

#endif //LAUNCH_CORE_UDPLAYER_
